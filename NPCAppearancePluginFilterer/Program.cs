using System;
using System.Collections.Generic;
using System.Linq;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using System.Threading.Tasks;
using System.IO;
using NPCAppearancePluginFilterer.Settings;
using Newtonsoft.Json;
using Newtonsoft.Json.Linq;
using Newtonsoft.Json.Converters;
using Noggog.Utility;
using Mutagen.Bethesda.Json;

namespace NPCAppearancePluginFilterer
{
    public class Program
    {
        static Lazy<NAPFsettings> Settings = null!;
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .SetAutogeneratedSettings(
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetTypicalOpen(GameRelease.SkyrimSE, "NAPF Output.esp")
                .Run(args);
        }

        private static void CanRunPatch(IRunnabilityState state)
        {
            NAPFsettings settings = Settings.Value;
            if (settings.AssetOutputDirectory != "" && !Directory.Exists(settings.AssetOutputDirectory))
            {
                throw new Exception("Cannot find output directory specified in settings: " + settings.AssetOutputDirectory);
            }

            if (settings.Mode != Mode.Simple && settings.MO2DataPath == "")
            {
                throw new Exception("MO2 Data Path must be set for any mode other than Simple.");
            }

            if (settings.MO2DataPath != "" && !Directory.Exists(settings.MO2DataPath))
            {
                throw new Exception("Cannot find the Mod Organizer 2 Mods folder specified in settings: " + settings.MO2DataPath);
            }
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            NAPFsettings settings = Settings.Value;

            NAPFsettings outputSettings = new NAPFsettings(); // only used if Mode == SettingsGen

            Dictionary<ModKey, string> PluginDirectoryDict = initPluginDirectoryDict(settings, state);

            getWarningsToSuppress(settings, state);

            if (settings.AssetOutputDirectory != "" && Directory.Exists(settings.AssetOutputDirectory) && settings.ClearAssetOutputDirectory && settings.Mode != Mode.SettingsGen)
            {
                clearOuptutDir(settings);
            }

            if (settings.Mode == Mode.SettingsGen)
            {
                string settingsDirName = "NAPF Settings";
                outputSettings.AssetOutputDirectory = settings.AssetOutputDirectory;
                outputSettings.ClearAssetOutputDirectory = settings.ClearAssetOutputDirectory;
                outputSettings.CopyExtraAssets = settings.CopyExtraAssets;
                outputSettings.MO2DataPath = settings.MO2DataPath;
                outputSettings.Mode = Mode.Deep;
                outputSettings.SuppressKnownMissingFileWarnings = settings.SuppressKnownMissingFileWarnings;

                int counter = 0;
                foreach (var npcCO in state.LoadOrder.PriorityOrder.Npc().WinningContextOverrides())
                {
                    if (npcCO.Record.FaceMorph == null)
                    {
                        continue; // skip creatures
                    }
                    generateSettingsForNPC(npcCO, settings, outputSettings, PluginDirectoryDict, state);
                    counter++;
                    if (counter % 100 == 0)
                    {
                        Console.WriteLine("Processed {0} humanoid NPCs", counter++);
                    }
                }

                // write output settings here

                var jsonSettings = new JsonSerializerSettings();
                jsonSettings.Converters.Add(new StringEnumConverter());
                jsonSettings.AddMutagenConverters();
                jsonSettings.ObjectCreationHandling = ObjectCreationHandling.Replace;
                jsonSettings.Formatting = Formatting.Indented;

                var outputPath = Path.Combine(settings.AssetOutputDirectory, settingsDirName, string.Format("settings_{0:yyyy-MM-dd_hh-mm-ss-tt}.json", DateTime.Now));
                try
                {
                    if (Directory.Exists(settings.AssetOutputDirectory) == false)
                    {
                        Directory.CreateDirectory(settings.AssetOutputDirectory);
                    }
                    if (Directory.Exists (Path.Combine(settings.AssetOutputDirectory, settingsDirName)) == false)
                    {
                        Directory.CreateDirectory(Path.Combine(settings.AssetOutputDirectory, settingsDirName));
                    }

                    string jsonStr = JsonConvert.SerializeObject(outputSettings, jsonSettings);
                    File.WriteAllText(outputPath, jsonStr);
                    Console.WriteLine("Wrote current settings to {0}. Use this file as a backup of your current settings by renaming it to \"settings.json\" and placing it into your Synthesis\\Data\\NPC-Appearance-Plugin-Filterer folder.", outputPath);
                }
                catch
                {
                    throw new Exception("Could not write the generated settings object to " + outputPath);
                }
            }

            else
            {
                foreach (var PPS in settings.PluginsToForward)
                {
                    Console.WriteLine("Processing {0}", PPS.Plugin.ToString());

                    if (PluginDirectoryDict.ContainsKey(PPS.Plugin) == false)
                    {
                        throw new Exception("Plugin -> Folder dictionary does not contain an entry for plugin " + PPS.Plugin.ToString());
                    }
                    string currentDataDir = PluginDirectoryDict[PPS.Plugin];

                    state.LoadOrder.TryGetValue(PPS.Plugin, out var currentModContext);
                    if (currentModContext != null && currentModContext.Mod != null)
                    {
                        foreach (var npc in currentModContext.Mod.Npcs)
                        {
                            if ((PPS.InvertSelection == false && PPS.NPCs.Contains(npc.AsLinkGetter())) || (PPS.InvertSelection == true && !PPS.NPCs.Contains(npc.AsLinkGetter())))
                            {
                                string NPCdispStr = npc.Name + " | " + npc.EditorID + " | " + npc.FormKey.ToString();
                                Console.WriteLine("Forwarding appearance of {0}", NPCdispStr);
                                if (faceGenExists(npc.FormKey, currentModContext.ModKey, currentDataDir, PPS.ExtraDataDirectories, settings.HandleBSAFiles_Patching, state, out var BSAfiles) == false)
                                {
                                    if (settings.AbortIfMissingFaceGen)
                                    {
                                        throw new Exception("Missing expected FaceGen for NPC " + NPCdispStr + " in folder " + currentDataDir + " (obtained based on plugin " + PPS.Plugin.ToString() + ")");
                                    }
                                    else
                                    {
                                        Console.WriteLine("WARNING: " + "Missing expected FaceGen for NPC " + NPCdispStr + " in folder " + currentDataDir + " (obtained based on plugin " + PPS.Plugin.ToString() + ")");
                                    }
                                }

                                var NPCoverride = addNPCtoPatch(npc, settings, state);
                                copyAssets(NPCoverride, currentModContext.ModKey, settings, currentDataDir, PPS, state);
                            }
                        }
                    }

                    //remap dependencies
                    if (settings.BaseGamePlugins.Contains(PPS.Plugin) == false)
                    {
                        Console.WriteLine("Remapping Dependencies from {0}.", PPS.Plugin.ToString());
                        state.PatchMod.DuplicateFromOnlyReferenced(state.LinkCache, PPS.Plugin, out var _);
                    }
                }
            }
        }      

        public static Npc addNPCtoPatch(INpcGetter userSelectedNPC, NAPFsettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            switch (settings.ForwardConflictWinnerData)
            {
                case false: return state.PatchMod.Npcs.GetOrAddAsOverride(userSelectedNPC);
                case true:
                    var allContexts = state.LinkCache.ResolveAllContexts<INpc, INpcGetter>(userSelectedNPC.FormKey)
                        .Take(2)
                        .ToList();
                    if (allContexts.Count < 2)
                    {
                        return state.PatchMod.Npcs.GetOrAddAsOverride(userSelectedNPC);
                    }
                    else
                    {
                        var winningOR = allContexts[^2].Record;
                        var forwardedOR = state.PatchMod.Npcs.GetOrAddAsOverride(winningOR);

                        if (forwardedOR.DefaultOutfit != null && userSelectedNPC.DefaultOutfit != null && settings.ForwardConflictWinnerOutifts)
                        {
                            forwardedOR.DefaultOutfit.SetTo(userSelectedNPC.DefaultOutfit);
                        }

                        if (forwardedOR.FaceMorph != null)
                        {
                            forwardedOR.FaceMorph.Clear();
                            if (userSelectedNPC.FaceMorph != null)
                            {
                                forwardedOR.FaceMorph.DeepCopyIn(userSelectedNPC.FaceMorph);
                            }
                        }
                        if (forwardedOR.FaceParts != null)
                        {
                            forwardedOR.FaceParts.Clear();
                            if (userSelectedNPC.FaceParts != null)
                            {
                                forwardedOR.FaceParts.DeepCopyIn(userSelectedNPC.FaceParts);
                            }
                        }
                        if(forwardedOR.FarAwayModel != null)
                        {
                            forwardedOR.FarAwayModel.Clear();
                            if (userSelectedNPC.FarAwayModel != null)
                            {
                                forwardedOR.FarAwayModel.SetTo(userSelectedNPC.FarAwayModel);
                            }
                        }
                        if (forwardedOR.HairColor != null && userSelectedNPC.HairColor != null)
                        {
                            forwardedOR.HairColor.SetTo(userSelectedNPC.HairColor);
                        }
                        if (forwardedOR.HeadParts != null)
                        {
                            forwardedOR.HeadParts.Clear();
                            if (userSelectedNPC.HeadParts != null)
                            {
                                forwardedOR.HeadParts.AddRange(userSelectedNPC.HeadParts);
                            }
                        }
                        
                        if (forwardedOR.HeadTexture != null )
                        {
                            forwardedOR.HeadTexture.Clear();
                            if (userSelectedNPC.HeadTexture != null)
                            {
                                forwardedOR.HeadTexture.SetTo(userSelectedNPC.HeadTexture);
                            }
                        }
                        forwardedOR.Height = userSelectedNPC.Height;
                        if(forwardedOR.Race != null && userSelectedNPC.Race != null)
                        {
                            forwardedOR.Race.SetTo(userSelectedNPC.Race);
                        }
                        if (forwardedOR.SleepingOutfit != null && userSelectedNPC.SleepingOutfit != null && settings.ForwardConflictWinnerOutifts)
                        {
                            forwardedOR.SleepingOutfit.SetTo(userSelectedNPC.SleepingOutfit);
                        }
                        if (forwardedOR.TextureLighting != null && userSelectedNPC.TextureLighting != null)
                        {
                            forwardedOR.TextureLighting = userSelectedNPC.TextureLighting;
                        }
                        if (forwardedOR.TintLayers != null)
                        {
                            forwardedOR.TintLayers.Clear();
                            if (userSelectedNPC.TintLayers != null)
                            {
                                forwardedOR.TintLayers.AddRange(userSelectedNPC.TintLayers.Select(a => a.DeepCopy()));
                            }
                        }
                        forwardedOR.Weight = userSelectedNPC.Weight;
                        
                        if (forwardedOR.WornArmor != null)
                        {
                            forwardedOR.WornArmor.Clear();
                            if (userSelectedNPC.WornArmor != null)
                            {
                                forwardedOR.WornArmor.SetTo(userSelectedNPC.WornArmor);
                            }
                        }

                        return forwardedOR;
                    }
            }
        }

        public static void clearOuptutDir(NAPFsettings settings)
        {
            string mPath = Path.Combine(settings.AssetOutputDirectory, "meshes");
            if (Directory.Exists(mPath))
            {
                DirectoryInfo diM = new DirectoryInfo(mPath);
                foreach (FileInfo file in diM.EnumerateFiles())
                {
                    file.Delete();
                }
                foreach (DirectoryInfo dir in diM.EnumerateDirectories())
                {
                    dir.Delete(true);
                }
            }

            string tPath = Path.Combine(settings.AssetOutputDirectory, "textures");
            if (Directory.Exists(tPath))
            {
                DirectoryInfo diM = new DirectoryInfo(tPath);
                foreach (FileInfo file in diM.EnumerateFiles())
                {
                    file.Delete();
                }
                foreach (DirectoryInfo dir in diM.EnumerateDirectories())
                {
                    dir.Delete(true);
                }
            }
        }
        public static void generateSettingsForNPC(IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter> npcCO, NAPFsettings settings, NAPFsettings outputSettings, Dictionary<ModKey, string> PluginDirectoryDict, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var contexts = state.LinkCache.ResolveAllContexts<INpc, INpcGetter>(npcCO.Record.FormKey);
            
            // skip if there are no overrides. Do this first to avoid having to do expensive BSA-enabled FaceGen check for large BSAs w/ few overrides such as Faalskar and LotD
            if (contexts.Count() == 1)
            {
                return;
            }

            // skip NPC if it has no modded facegen
            if (faceGenExists(npcCO.Record.FormKey, npcCO.ModKey, state.DataFolderPath, new HashSet<string>(), settings.HandleBSAFiles_SettingsGen, state, out var inBSA) == false) // npcCo.ModKey is only used to open BSA files - make sure this corresponds to the ModKey of the winning override.
            {
                return;
            }

            foreach (var context in contexts)
            {
                if (settings.BaseGamePlugins.Contains(context.ModKey) || context.ModKey == npcCO.Record.FormKey.ModKey) // if the current plugin is from the excluded list, or if it is the base plugin, skip
                {
                    continue;
                }

                if (!PluginDirectoryDict.ContainsKey(context.ModKey)) { continue; } // possible if source plugin is in the overwrite folder, in which case it should be ignored

                string currentDataDir = PluginDirectoryDict[context.ModKey];

                // check if NPC's facegen matches the winning facegen
                if (checkFaceGenMatch(context, currentDataDir, settings.HandleBSAFiles_SettingsGen, state) == true)
                {
                    // get the relevant plugin settings object
                    var currentPPS = new PerPluginSettings();
                    bool foundCurrentPPS = false;
                    foreach (var PPS in outputSettings.PluginsToForward)
                    {
                        if (PPS.Plugin == context.ModKey)
                        {
                            currentPPS = PPS;
                            foundCurrentPPS = true;
                            break;
                        }
                    }
                    if (foundCurrentPPS == false)
                    {
                        currentPPS.Plugin = context.ModKey;
                        currentPPS.InvertSelection = false;
                        outputSettings.PluginsToForward.Add(currentPPS);
                    }

                    currentPPS.NPCs.Add(npcCO.Record.AsLinkGetter());
                    break;
                }
            }
        }

        public static bool faceGenExists(FormKey NPCFormKey, ModKey currentModKey, string rootPath, HashSet<string> extraDataPaths, bool handleBSAFiles, IPatcherState<ISkyrimMod, ISkyrimModGetter> state, out (IArchiveFile?, IArchiveFile?) BSAFiles)
        {
            var FaceGenSubPaths = getFaceGenSubPathStrings(NPCFormKey);

            var BSAreaders = new HashSet<IArchiveReader>();
            if (handleBSAFiles)
            {
                BSAreaders = BSAHandler.openBSAArchiveReaders(rootPath, currentModKey);
            }
            BSAFiles = (null, null);

            // check for nif
            bool bNifExists = false;
            string FaceGenNifSubPath = Path.Combine(rootPath, "meshes", FaceGenSubPaths.Item1);
            if (File.Exists(FaceGenNifSubPath))
            {
                bNifExists = true;
            }
            else
            {
                if (handleBSAFiles && BSAreaders.Any())
                {
                    foreach (var reader in BSAreaders)
                    {
                        if (BSAHandler.TryGetFile(Path.Combine("meshes", FaceGenSubPaths.Item1), reader, out var nifFile))
                        {
                            bNifExists = true;
                            BSAFiles.Item1 = nifFile;
                            break;
                        }
                    }
                }

                if (bNifExists == false)
                {
                    foreach (string path in extraDataPaths)
                    {
                        if (File.Exists(FaceGenNifSubPath))
                        {
                            bNifExists = true;
                            break;
                        }
                    }
                }
            }

            if (bNifExists == false)
            {
                return false;
            }

            // check for Dds
            bool bDdsExists = false;
            string FaceGenDdsSubPath = Path.Combine(rootPath, "textures", FaceGenSubPaths.Item2);
            if (File.Exists(FaceGenDdsSubPath))
            {
                bDdsExists = true;
            }
            else
            {
                if (handleBSAFiles && BSAreaders.Any())
                {
                    foreach (var reader in BSAreaders)
                    {
                        if (BSAHandler.TryGetFile(Path.Combine("textures", FaceGenSubPaths.Item2), reader, out var DdsFile))
                        {
                            bDdsExists = true;
                            BSAFiles.Item2 = DdsFile;
                            break;
                        }
                    }
                }

                if (bDdsExists == false)
                {
                    foreach (string path in extraDataPaths)
                    {
                        if (File.Exists(FaceGenDdsSubPath))
                        {
                            bDdsExists = true;
                            break;
                        }
                    }
                }
            }

            if (bDdsExists == false)
            {
                return false;
            }


            return true;
        }

        public static bool checkFaceGenMatch(IModContext<ISkyrimMod, ISkyrimModGetter, INpc, INpcGetter> npcCO, string currentModDir, bool handleBSAFiles, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            var FaceGenSubPaths = getFaceGenSubPathStrings(npcCO.Record.FormKey);

            string modMeshPath = Path.Combine(currentModDir, "meshes", FaceGenSubPaths.Item1);

            HashSet<IArchiveReader> readers = new HashSet<IArchiveReader>();
            if (handleBSAFiles)
            {
                readers = BSAHandler.openBSAArchiveReaders(currentModDir, npcCO.ModKey);
            }

            if (File.Exists(modMeshPath) == false && (handleBSAFiles && BSAHandler.HaveFile(modMeshPath, readers)) == false) // If the given override doesn't provide facegen, then it trivially is not the facegen conflict winner
            {
                return false;
            }

            string winnerMeshPath = Path.Combine(state.DataFolderPath, "meshes", FaceGenSubPaths.Item1); 

            if (FileComparison.FilesAreEqual(modMeshPath, winnerMeshPath) == false) 
            {
                return false;
            }

            string modTexPath = Path.Combine(currentModDir, "textures", FaceGenSubPaths.Item2); 
            
            if (File.Exists(modTexPath) == false && (handleBSAFiles && BSAHandler.HaveFile(modTexPath, readers)) == false) // If the given override doesn't provide facegen, then it trivially is not the facegen conflict winner
            {
                return false;
            }

            string winnerTexPath = Path.Combine(state.DataFolderPath, "textures", FaceGenSubPaths.Item2);

            if (FileComparison.FilesAreEqual(modTexPath, winnerTexPath) == false)
            {
                return false;
            }

            return true;
        }

        public static void getWarningsToSuppress(NAPFsettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            string settingsPath = Path.Combine(state.ExtraSettingsDataPath, "Warnings To Suppress.json");
            if (!File.Exists(settingsPath) && settings.SuppressKnownMissingFileWarnings)
            {
                throw new Exception("Could not find the list of known missing files (expected at: " + settingsPath + ").");
            }

            try
            {
                var tempJArray = JArray.Parse(File.ReadAllText(settingsPath));
                foreach (var s in tempJArray)
                {
                    settings.warningsToSuppress.Add(s.ToString().Replace(@"\\", @"\"));
                }

                if (settings.SuppressKnownMissingFileWarnings)
                {
                    Console.WriteLine("Found list of known missing files to suppress (contains {0} entries).", settings.warningsToSuppress.Count);
                }
            }
            catch
            {
                throw new Exception("Could not parse the list of known missing files (expected at: " + settingsPath + ").");
            }
        }

        public static void getPathstoIgnore(NAPFsettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            string settingsPath = Path.Combine(state.ExtraSettingsDataPath, "Paths To Ignore.json");
            if (!File.Exists(settingsPath))
            {
                throw new Exception("Could not find the list of asset paths to ignore (expected at: " + settingsPath + ").");
            }

            try
            {
                var tempJArray = JArray.Parse(File.ReadAllText(settingsPath));
                foreach (var s in tempJArray)
                {
                    settings.pathsToIgnore.Add(s.ToString().Replace(@"\\", @"\"));
                }
            }
            catch
            {
                throw new Exception("Could not parse the list of asset paths to ignore (expected at: " + settingsPath + ").");
            }
        }

        public static Dictionary<ModKey, string> initPluginDirectoryDict(NAPFsettings settings, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            Dictionary<ModKey, string> PluginDirectoryDict = new Dictionary<ModKey, string>();
            if (settings.MO2DataPath == null || settings.MO2DataPath.Length == 0)
            {
                return PluginDirectoryDict;
            }

            if (settings.GameDirPath != "" && Directory.Exists(settings.GameDirPath) == false)
            {
                throw new Exception("Could not find the game directory at " + settings.GameDirPath);
            }

            if (settings.Mode == Mode.SettingsGen)
            {
                foreach (var mkPair in state.LoadOrder)
                {
                    var mk = mkPair.Key;

                    if (settings.BaseGamePlugins.Contains(mk)) 
                    {
                        PluginDirectoryDict.Add(mk, Path.Combine(settings.GameDirPath, "data"));
                        continue; 
                    }

                    bool dirFound = false;
                    foreach (var dirName in Directory.GetDirectories(settings.MO2DataPath))
                    {
                        string potentialPath = Path.Join(dirName, mk.ToString());
                        if (File.Exists(potentialPath))
                        {
                            PluginDirectoryDict.Add(mk, dirName);
                            dirFound = true;
                            break;
                        }
                    }
                    if (dirFound == false)
                    {
                        Console.WriteLine("Could not find a mod folder for plugin {0}. Assuming this plugin is in the Overwrite folder and is not an appearance-related plugin.", mk.ToString());
                    }
                }
            }
            else
            {
                string baseDataFolder = Path.Combine(settings.GameDirPath, "data");
                foreach (var PPS in settings.PluginsToForward)
                {
                    if (PPS.Plugin != null)
                    {
                        switch (settings.Mode)
                        {
                            case Mode.Deep:
                                // forced directory overrides even baseDataFolder
                                if (PPS.ForcedAssetDirectory != "")
                                {
                                    if (Directory.Exists(PPS.ForcedAssetDirectory) == false)
                                    {
                                        throw new Exception("Could not find forced asset directory for plugin " + PPS.Plugin.ToString() + " at " + PPS.ForcedAssetDirectory);
                                    }
                                    PluginDirectoryDict.Add(PPS.Plugin, PPS.ForcedAssetDirectory);
                                    break;
                                }
                                if (settings.BaseGamePlugins.Contains(PPS.Plugin))
                                {
                                    if (settings.GameDirPath == "")
                                    {
                                        throw new Exception("Forwarding appearance from a base game plugin requires the Game Directory to be set");
                                    }
                                    if (Directory.Exists(baseDataFolder) == false)
                                    {
                                        throw new Exception("User requested a plugin to be forwarded from base game plugin " + PPS.Plugin + " but Game Data directory " + baseDataFolder + " cannot be found.");
                                    }
                                    PluginDirectoryDict.Add(PPS.Plugin, baseDataFolder);
                                    break;
                                }

                                bool dirFound = false;
                                foreach (var dirName in Directory.GetDirectories(settings.MO2DataPath))
                                {
                                    string potentialPath = Path.Join(dirName, PPS.Plugin.ToString());
                                    if (File.Exists(potentialPath))
                                    {
                                        PluginDirectoryDict.Add(PPS.Plugin, dirName);
                                        dirFound = true;
                                        break;
                                    }
                                }
                                if (dirFound == false)
                                {
                                    throw new Exception("Cannot find any folder within " + settings.MO2DataPath + " that contains plugin " + PPS.Plugin.ToString());
                                }
                                break;

                            case Mode.Simple:
                                PluginDirectoryDict.Add(PPS.Plugin, state.DataFolderPath);
                                break;
                        }
                    }
                }
            }
            return PluginDirectoryDict;
        }

        public static void copyAssets(Npc npc, ModKey NPCModKey, NAPFsettings settings, string currentModDirectory, PerPluginSettings PPS, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            HashSet<string> meshes = new HashSet<string>();
            HashSet<string> textures = new HashSet<string>();

            //FaceGen
            var FaceGenSubPaths = getFaceGenSubPathStrings(npc.FormKey);
            meshes.Add(FaceGenSubPaths.Item1);
            textures.Add(FaceGenSubPaths.Item2);

            if (settings.CopyExtraAssets)
            {
                getAssetsReferencedByplugin(npc, settings, meshes, textures, state);
            }

            //extract needed files from BSA
            HashSet<string> extractedMeshFiles = new HashSet<string>();
            HashSet<string> extractedTexFiles = new HashSet<string>();
            if (settings.HandleBSAFiles_Patching) // if settings.CopyExtraAssets is disabled, then only FaceGen will be extracted here (if in BSA)
            {
                unpackAssetsFromBSA(meshes, textures, extractedMeshFiles, extractedTexFiles, NPCModKey, currentModDirectory, settings); // meshes and textures are edited in this function - found & extracted files are removed from the HashSets. Only loose files remain
            } // end BSA handling for extra assets found in plugin


            if (settings.CopyExtraAssets && PPS.FindExtraTexturesInNif)
            {
                HashSet<string> alreadyHandledTextures = new HashSet<string>(textures, StringComparer.OrdinalIgnoreCase); // ignored these if found in nif because they have already been processed
                alreadyHandledTextures.UnionWith(extractedTexFiles); // will simply be empty if settings.HandleBSAFiles_Patching == false

                HashSet<string> extraTexturesFromNif = new HashSet<string>();
                getExtraTexturesFromNif(meshes, currentModDirectory, extraTexturesFromNif, alreadyHandledTextures); //traverse nifs for extra textures (loose nifs - in mod folder)

                if (settings.HandleBSAFiles_Patching)
                {
                    getExtraTexturesFromNif(extractedMeshFiles, settings.AssetOutputDirectory, extraTexturesFromNif, alreadyHandledTextures); //traverse nifs for extra textures (BSA extracted nifs - in output folder)
                    
                    // extract these additional textures from BSA if possible
                    HashSet<string> ExtractedExtraTextures = new HashSet<string>();
                    unpackAssetsFromBSA(new HashSet<string>(), extraTexturesFromNif, new HashSet<string>(), ExtractedExtraTextures, NPCModKey, currentModDirectory, settings); // if any additional textures live the BSA, unpack them
                    
                    // remove BSA-unpacked textures from the additional texture list
                    foreach (string s in ExtractedExtraTextures)
                    {
                        extraTexturesFromNif.Remove(s);
                    }
                }
                // copy extra texture list to output texture list
                foreach (string s in extraTexturesFromNif)
                {
                    textures.Add(s);
                }

            }

            // copy loose files
            copyAssetFiles(settings, currentModDirectory, meshes, PPS.ExtraDataDirectories, "Meshes");
            copyAssetFiles(settings, currentModDirectory, textures, PPS.ExtraDataDirectories, "Textures");
        }

        public static void getExtraTexturesFromNif(HashSet<string> NifPaths, string NifDirectory, HashSet<string> outputTextures, HashSet<string> ignoredTextures)
        {
            foreach (var nifpath in NifPaths)
            {
                string fullPath = Path.Combine(NifDirectory, "meshes", nifpath);
                if (Path.GetExtension(nifpath) == ".nif" && File.Exists(fullPath))
                {
                    var nifTextures = NifHandler.getExtraTexturesFromNif(fullPath);
                    foreach (var t in nifTextures)
                    {
                        if (outputTextures.Contains(t) == false && ignoredTextures.Contains(t) == false)
                        {
                            outputTextures.Add(t);
                        }
                    }
                }
            }
        }

        public static void unpackAssetsFromBSA(HashSet<string> MeshesToExtract, HashSet<string> TexturesToExtract, HashSet<string> extractedMeshes, HashSet<string> ExtractedTextures, ModKey currentModKey, string currentModDirectory, NAPFsettings settings)
        {
            var BSAreaders = BSAHandler.openBSAArchiveReaders(currentModDirectory, currentModKey);
            foreach (string subPath in MeshesToExtract)
            {
                string meshPath = Path.Combine("meshes", subPath);
                foreach (var reader in BSAreaders)
                {
                    if (BSAHandler.TryGetFile(meshPath, reader, out var file) && file != null)
                    {
                        extractedMeshes.Add(subPath);
                        string destFile = Path.Combine(settings.AssetOutputDirectory, meshPath);
                        BSAHandler.extractFileFromBSA(file, destFile);
                        break;
                    }
                }
            }

            foreach (string subPath in TexturesToExtract)
            {
                string texPath = Path.Combine("textures", subPath);
                foreach (var reader in BSAreaders)
                {
                    if (BSAHandler.TryGetFile(texPath, reader, out var file) && file != null)
                    {
                        ExtractedTextures.Add(subPath);
                        string destFile = Path.Combine(settings.AssetOutputDirectory, texPath);
                        BSAHandler.extractFileFromBSA(file, destFile);
                        break;
                    }
                }
            }

            // remove extracted files from list, which should now only contain loose files
            foreach (string s in extractedMeshes)
            {
                MeshesToExtract.Remove(s);
            }
            foreach (String s in ExtractedTextures)
            {
                TexturesToExtract.Remove(s);
            }
        }

        public static void getAssetsReferencedByplugin(Npc npc, NAPFsettings settings, HashSet<string> meshes, HashSet<string> textures, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            //headparts
            foreach (var hp in npc.HeadParts)
            {
                if (!settings.PluginsExcludedFromMerge.Contains(hp.FormKey.ModKey))
                {
                    getHeadPartAssetPaths(hp, textures, meshes, settings.PluginsExcludedFromMerge, state);
                }
            }

            // armor and armature
            if (npc.WornArmor != null && state.LinkCache.TryResolve<IArmorGetter>(npc.WornArmor.FormKey, out var wnamGetter) && wnamGetter.Armature != null)
            {
                foreach (var aa in wnamGetter.Armature)
                {
                    if (!settings.PluginsExcludedFromMerge.Contains(aa.FormKey.ModKey))
                    {
                        {
                            getARMAAssetPaths(aa, textures, meshes, settings.PluginsExcludedFromMerge, state);
                        }
                    }
                }
            }
        }

        public static (string, string) getFaceGenSubPathStrings(FormKey npcFormKey)
        {
            string meshPath = "actors\\character\\facegendata\\facegeom\\" + npcFormKey.ModKey.ToString() + "\\00" + npcFormKey.IDString() + ".nif";
            string texPath = "actors\\character\\facegendata\\facetint\\" + npcFormKey.ModKey.ToString() + "\\00" + npcFormKey.IDString() + ".dds";
            return (meshPath, texPath);
        }

        public static void copyAssetFiles(NAPFsettings settings, string dataPath, HashSet<string> assetPathList, HashSet<string> ExtraDataDirectories, string type)
        {
            string outputPrepend = Path.Combine(settings.AssetOutputDirectory, type);
            if (Directory.Exists(outputPrepend) == false)
            {
                Directory.CreateDirectory(outputPrepend);
            }

            foreach (string s in assetPathList)
            {
                if (!isIgnored(s, settings.pathsToIgnore))
                {
                    string currentPath = Path.Join(dataPath, type, s);
                    
                    bool bFileExists = false;
                    // check if file exists at primary path
                    if (File.Exists(currentPath))
                    {
                        bFileExists = true;
                    }
                    else
                    {
                        // check if file exists in the specified extra data paths
                        foreach (string extraDir in ExtraDataDirectories)
                        {
                            currentPath = Path.Join(extraDir, type, s);
                            if (File.Exists(currentPath))
                            {
                                bFileExists = true;
                                break;
                            }
                        }
                    }

                    if (bFileExists == false)
                    {
                        if (!(settings.SuppressKnownMissingFileWarnings && settings.warningsToSuppress.Any(s => s.Equals(s, StringComparison.OrdinalIgnoreCase)))) // nested if statement intentional; otherwise a suppressed warning goes into the else block despite the target file not existing
                        {
                            if (settings.AbortIfMissingExtraAssets)
                            {
                                if (ExtraDataDirectories.Count == 0)
                                {
                                    throw new Exception("Extra Asset " + currentPath + " was not found.");
                                }
                                else
                                {
                                    throw new Exception("Extra Asset " + s + " was not found in " + dataPath + " or any Extra Data Directories.");
                                }
                            }
                            else
                            {
                                if (ExtraDataDirectories.Count == 0)
                                {
                                    Console.WriteLine("Warning: Extra Asset " + currentPath + " was not found.");
                                }
                                else
                                {
                                    Console.WriteLine("Warning: Extra Asset " + s + " was not found in " + dataPath + " or any Extra Data Directories.");
                                }
                            }
                        }
                    }
                    else
                    {
                        string destPath = Path.Join(outputPrepend, s);

                        FileInfo fileInfo = new FileInfo(destPath);
                        if (fileInfo != null && fileInfo.Directory != null && !fileInfo.Directory.Exists)
                        {
                            Directory.CreateDirectory(fileInfo.Directory.FullName);
                        }

                        File.Copy(currentPath, destPath, true);
                    }
                }
            }
        }

        public static bool isIgnored (string s, HashSet<string> toIgnore)
        {
            string l = s.ToLower();
            foreach (string ig in toIgnore)
            {
                if (ig.ToLower() == l)
                {
                    return true;
                }
            }
            return false;
        }

        public static void getARMAAssetPaths(IFormLinkGetter<IArmorAddonGetter> aa, HashSet<string> texturePaths, HashSet<string> meshPaths, HashSet<ModKey> PluginsExcludedFromMerge, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (!state.LinkCache.TryResolve<IArmorAddonGetter>(aa.FormKey, out var aaGetter))
            {
                return;
            }

            if (aaGetter.WorldModel != null && aaGetter.WorldModel.Male != null && aaGetter.WorldModel.Male.File != null)
            {
                meshPaths.Add(aaGetter.WorldModel.Male.File);
            }
            if (aaGetter.WorldModel != null && aaGetter.WorldModel.Female != null && aaGetter.WorldModel.Female.File != null)
            {
                meshPaths.Add(aaGetter.WorldModel.Female.File);
            }

            if (aaGetter.SkinTexture != null && aaGetter.SkinTexture.Male != null && !PluginsExcludedFromMerge.Contains(aaGetter.SkinTexture.Male.FormKey.ModKey) && state.LinkCache.TryResolve<ITextureSetGetter>(aaGetter.SkinTexture.Male.FormKey, out var mSkinTxst))
            {
                getTextureSetPaths(mSkinTxst, texturePaths);
            }
            if (aaGetter.SkinTexture != null && aaGetter.SkinTexture.Female != null && !PluginsExcludedFromMerge.Contains(aaGetter.SkinTexture.Female.FormKey.ModKey) && state.LinkCache.TryResolve<ITextureSetGetter>(aaGetter.SkinTexture.Female.FormKey, out var fSkinTxst))
            {
                getTextureSetPaths(fSkinTxst, texturePaths);
            }
        }

        public static void getHeadPartAssetPaths(IFormLinkGetter<IHeadPartGetter> hp, HashSet<string> texturePaths, HashSet<string> meshPaths, HashSet<ModKey> PluginsExcludedFromMerge, IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            if (!state.LinkCache.TryResolve<IHeadPartGetter>(hp.FormKey, out var hpGetter))
            {
                return;
            }

            if (hpGetter.Model != null && hpGetter.Model.File != null)
            {
                meshPaths.Add(hpGetter.Model.File);
            }

            if (hpGetter.Parts != null)
            {
                foreach (var part in hpGetter.Parts)
                {
                    if (part.FileName != null)
                    {
                        meshPaths.Add(part.FileName);
                    }
                }
            }

            if (hpGetter.TextureSet != null && state.LinkCache.TryResolve<ITextureSetGetter>(hpGetter.TextureSet.FormKey, out var hTxst))
            {
                getTextureSetPaths(hTxst, texturePaths);
            }

            if (hpGetter.ExtraParts != null)
            {
                foreach (var EP in hpGetter.ExtraParts)
                {
                    if (!PluginsExcludedFromMerge.Contains(EP.FormKey.ModKey))
                    {
                        getHeadPartAssetPaths(EP, texturePaths, meshPaths, PluginsExcludedFromMerge, state);
                    }
                }
            }
        }

        public static void getTextureSetPaths(ITextureSetGetter Txst, HashSet<string> texturePaths)
        {
            if (Txst.Diffuse != null)
            {
                texturePaths.Add(Txst.Diffuse);
            }
            if (Txst.NormalOrGloss != null)
            {
                texturePaths.Add(Txst.NormalOrGloss);
            }
            if (Txst.BacklightMaskOrSpecular != null)
            {
                texturePaths.Add(Txst.BacklightMaskOrSpecular);
            }
            if (Txst.Environment != null)
            {
                texturePaths.Add(Txst.Environment);
            }
            if (Txst.EnvironmentMaskOrSubsurfaceTint != null)
            {
                texturePaths.Add(Txst.EnvironmentMaskOrSubsurfaceTint);
            }
            if (Txst.GlowOrDetailMap != null)
            {
                texturePaths.Add(Txst.GlowOrDetailMap);
            }
        }
    }
}
